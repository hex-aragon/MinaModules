import { Proof } from '../../proof-system/zkprogram.js';
import { Unconstrained } from '../../provable/types/unconstrained.js';
import { MerkleList, MerkleListIterator } from '../../provable/merkle-list.js';
import { MerkleTree } from '../../provable/merkle-tree.js';
import { SelfProof } from '../../proof-system/zkprogram.js';
import { Provable } from '../../provable/provable.js';
import { MerkleLeaf } from './offchain-state-serialization.js';
export { OffchainStateRollup, OffchainStateCommitments };
declare const OffchainStateCommitments_base: (new (value: {
    root: import("../../provable/field.js").Field;
    actionState: import("../../provable/field.js").Field;
}) => {
    root: import("../../provable/field.js").Field;
    actionState: import("../../provable/field.js").Field;
}) & {
    _isStruct: true;
} & Omit<import("../../provable/types/provable-intf.js").Provable<{
    root: import("../../provable/field.js").Field;
    actionState: import("../../provable/field.js").Field;
}, {
    root: bigint;
    actionState: bigint;
}>, "fromFields"> & {
    fromFields: (fields: import("../../provable/field.js").Field[]) => {
        root: import("../../provable/field.js").Field;
        actionState: import("../../provable/field.js").Field;
    };
} & {
    fromValue: (value: {
        root: string | number | bigint | import("../../provable/field.js").Field;
        actionState: string | number | bigint | import("../../provable/field.js").Field;
    }) => {
        root: import("../../provable/field.js").Field;
        actionState: import("../../provable/field.js").Field;
    };
    toInput: (x: {
        root: import("../../provable/field.js").Field;
        actionState: import("../../provable/field.js").Field;
    }) => {
        fields?: import("../../provable/field.js").Field[] | undefined;
        packed?: [import("../../provable/field.js").Field, number][] | undefined;
    };
    toJSON: (x: {
        root: import("../../provable/field.js").Field;
        actionState: import("../../provable/field.js").Field;
    }) => {
        root: string;
        actionState: string;
    };
    fromJSON: (x: {
        root: string;
        actionState: string;
    }) => {
        root: import("../../provable/field.js").Field;
        actionState: import("../../provable/field.js").Field;
    };
    empty: () => {
        root: import("../../provable/field.js").Field;
        actionState: import("../../provable/field.js").Field;
    };
};
/**
 * Commitments that keep track of the current state of an offchain Merkle tree constructed from actions.
 * Intended to be stored on-chain.
 *
 * Fields:
 * - `root`: The root of the current Merkle tree
 * - `actionState`: The hash pointing to the list of actions that have been applied to form the current Merkle tree
 */
declare class OffchainStateCommitments extends OffchainStateCommitments_base {
    static empty(): OffchainStateCommitments;
}
/**
 * This program represents a proof that we can go from OffchainStateCommitments A -> B
 */
declare function OffchainStateRollup({ maxActionsPerBatch, maxActionsPerUpdate, }?: {
    maxActionsPerBatch?: number | undefined;
    maxActionsPerUpdate?: number | undefined;
}): {
    Proof: {
        new ({ proof, publicInput, publicOutput, maxProofsVerified, }: {
            proof: unknown;
            publicInput: OffchainStateCommitments;
            publicOutput: OffchainStateCommitments;
            maxProofsVerified: 0 | 2 | 1;
        }): {
            verify(): void;
            verifyIf(condition: import("../../provable/bool.js").Bool): void;
            publicInput: OffchainStateCommitments;
            publicOutput: OffchainStateCommitments;
            proof: unknown;
            maxProofsVerified: 0 | 2 | 1;
            shouldVerify: import("../../provable/bool.js").Bool;
            toJSON(): import("../../proof-system/zkprogram.js").JsonProof;
        };
        publicInputType: typeof OffchainStateCommitments;
        publicOutputType: typeof OffchainStateCommitments;
        tag: () => {
            name: string;
            publicInputType: typeof OffchainStateCommitments;
            publicOutputType: typeof OffchainStateCommitments;
        };
        fromJSON<S extends (new (...args: any) => Proof<unknown, unknown>) & {
            prototype: Proof<any, any>;
            fromJSON: typeof Proof.fromJSON;
            dummy: typeof Proof.dummy;
            publicInputType: import("../../provable/types/struct.js").FlexibleProvablePure<any>;
            publicOutputType: import("../../provable/types/struct.js").FlexibleProvablePure<any>;
            tag: () => {
                name: string;
            };
        } & {
            prototype: Proof<unknown, unknown>;
        }>(this: S, { maxProofsVerified, proof: proofString, publicInput: publicInputJson, publicOutput: publicOutputJson, }: import("../../proof-system/zkprogram.js").JsonProof): Promise<Proof<import("../../provable/types/provable-derivers.js").InferProvable<S["publicInputType"]>, import("../../provable/types/provable-derivers.js").InferProvable<S["publicOutputType"]>>>;
        dummy<Input, OutPut>(publicInput: Input, publicOutput: OutPut, maxProofsVerified: 0 | 2 | 1, domainLog2?: number): Promise<Proof<Input, OutPut>>;
    };
    program: {
        name: string;
        compile: (options?: {
            cache?: import("../../proof-system/cache.js").Cache | undefined;
            forceRecompile?: boolean | undefined;
        } | undefined) => Promise<{
            verificationKey: {
                data: string;
                hash: import("../../provable/field.js").Field;
            };
        }>;
        verify: (proof: Proof<OffchainStateCommitments, OffchainStateCommitments>) => Promise<boolean>;
        digest: () => Promise<string>;
        analyzeMethods: () => Promise<{
            firstBatch: {
                rows: number;
                digest: string;
                gates: import("../../../snarky.js").Gate[];
                publicInputSize: number;
                print(): void;
                summary(): Partial<Record<import("../../../snarky.js").GateType | "Total rows", number>>;
            };
            nextBatch: {
                rows: number;
                digest: string;
                gates: import("../../../snarky.js").Gate[];
                publicInputSize: number;
                print(): void;
                summary(): Partial<Record<import("../../../snarky.js").GateType | "Total rows", number>>;
            };
        }>;
        publicInputType: typeof OffchainStateCommitments;
        publicOutputType: typeof OffchainStateCommitments;
        privateInputTypes: {
            firstBatch: [import("../../provable/crypto/poseidon.js").ProvableHashable<MerkleListIterator<MerkleList<{
                key: import("../../provable/field.js").Field;
                value: import("../../provable/field.js").Field;
                usesPreviousValue: import("../../provable/bool.js").Bool;
                previousValue: import("../../provable/field.js").Field;
                prefix: Unconstrained<import("../../provable/field.js").Field[]>;
            }>>>, Provable<Unconstrained<any>, Unconstrained<any>> & {
                toInput: (x: Unconstrained<any>) => {
                    fields?: import("../../provable/field.js").Field[] | undefined;
                    packed?: [import("../../provable/field.js").Field, number][] | undefined;
                };
                empty: () => Unconstrained<any>;
            }];
            nextBatch: [import("../../provable/crypto/poseidon.js").ProvableHashable<MerkleListIterator<MerkleList<{
                key: import("../../provable/field.js").Field;
                value: import("../../provable/field.js").Field;
                usesPreviousValue: import("../../provable/bool.js").Bool;
                previousValue: import("../../provable/field.js").Field;
                prefix: Unconstrained<import("../../provable/field.js").Field[]>;
            }>>>, Provable<Unconstrained<any>, Unconstrained<any>> & {
                toInput: (x: Unconstrained<any>) => {
                    fields?: import("../../provable/field.js").Field[] | undefined;
                    packed?: [import("../../provable/field.js").Field, number][] | undefined;
                };
                empty: () => Unconstrained<any>;
            }, typeof SelfProof];
        };
        rawMethods: {
            firstBatch: (publicInput: OffchainStateCommitments, ...args: [MerkleListIterator<MerkleList<{
                key: import("../../provable/field.js").Field;
                value: import("../../provable/field.js").Field;
                usesPreviousValue: import("../../provable/bool.js").Bool;
                previousValue: import("../../provable/field.js").Field;
                prefix: Unconstrained<import("../../provable/field.js").Field[]>;
            }>>, Unconstrained<any>] & any[]) => Promise<OffchainStateCommitments>;
            nextBatch: (publicInput: OffchainStateCommitments, ...args: [MerkleListIterator<MerkleList<{
                key: import("../../provable/field.js").Field;
                value: import("../../provable/field.js").Field;
                usesPreviousValue: import("../../provable/bool.js").Bool;
                previousValue: import("../../provable/field.js").Field;
                prefix: Unconstrained<import("../../provable/field.js").Field[]>;
            }>>, Unconstrained<any>, SelfProof<unknown, unknown>] & any[]) => Promise<OffchainStateCommitments>;
        };
    } & {
        firstBatch: (publicInput: OffchainStateCommitments, ...args: [MerkleListIterator<MerkleList<{
            key: import("../../provable/field.js").Field;
            value: import("../../provable/field.js").Field;
            usesPreviousValue: import("../../provable/bool.js").Bool;
            previousValue: import("../../provable/field.js").Field;
            prefix: Unconstrained<import("../../provable/field.js").Field[]>;
        }>>, Unconstrained<any>] & any[]) => Promise<Proof<OffchainStateCommitments, OffchainStateCommitments>>;
        nextBatch: (publicInput: OffchainStateCommitments, ...args: [MerkleListIterator<MerkleList<{
            key: import("../../provable/field.js").Field;
            value: import("../../provable/field.js").Field;
            usesPreviousValue: import("../../provable/bool.js").Bool;
            previousValue: import("../../provable/field.js").Field;
            prefix: Unconstrained<import("../../provable/field.js").Field[]>;
        }>>, Unconstrained<any>, SelfProof<unknown, unknown>] & any[]) => Promise<Proof<OffchainStateCommitments, OffchainStateCommitments>>;
    };
    compile(): Promise<{
        verificationKey: {
            data: string;
            hash: import("../../provable/field.js").Field;
        };
    } | undefined>;
    prove(tree: MerkleTree, actions: MerkleList<MerkleList<MerkleLeaf>>): Promise<{
        proof: Proof<OffchainStateCommitments, OffchainStateCommitments>;
        tree: MerkleTree;
        nProofs: number;
    }>;
};
